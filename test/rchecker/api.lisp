(in-package #:rchecker)
(defparameter *cells* (make-hash-table))
(defun clear-events() (setf *cells* (make-hash-table)))
(defun get-event(key) (assert (gethash key *cells*)) (gethash key *cells*))
(defun has-event(key) (gethash key *cells*))
(defun fire-event(key)  #'(lambda(val) (assert val) (setf (gethash key *cells*) val)))
(defun clear-event(key)  (setf (gethash key *cells*) nil))

(defun tr-request(method url &optional body)
  #'(lambda()
      (list (if (listp url)(format nil "窿薤" url)
                url)
            method '(("Content-type" "application/json"))
            (when body  (jsown:to-json body))) ) )

(defun http-get (url &rest urls)  (tr-request :get (list* url urls)))
(defun http-del (url &rest urls)  (tr-request :delete (list* url urls)) )
(defun http-put(url body) (tr-request :put url body))
(defun http-post(url body) (tr-request :post url body))

(defun contains(key)
  #'(lambda(js)
      (member key (jsown:keywords js) :test #'equal)))

(defun get-id(&optional (prefix "tr")) (format nil "A-窿窿立痱彐轼篚怏羼眭祠轲戾鲠祯瀛扉篝ㄤ邈镤瀛躅轹弪筢飙糸礤ㄧ弭躅轹弪筢飙糸礤┅穿篚怏羼篝蜷铉ㄧ孱簌愆┍蜥钿镯卑鞍┅ㄤ彐躅趄篝屦蝈聃弩汨邈弼孱趔戾è牦ㄡ痧禊ㄦ躅汜祆孱漯镩铘趄犷箴矧舡潋犭磲┅ㄦ躅汜祆蝈聃弩舂┅麒孱ㄦ躅汜祆汨邈牦ㄦ躅汜祆弼孱趔牦┅牦┅ㄤ彐躅篦徵珏颞趄篝屦ㄨ趑瓠珏篦徵珏虍牦镱ㄣ镱篝犷綮舂＇殇孱糸豉┅ㄤ彐鲠躅轼屦镢璀溟骀弪孱沐ㄥ钽镤瀛躅轹弪筢飙糸礤惫钒癌ㄤ彐躅躅轹弪筢飙麸躅轼糸礤躅轹弪筢飙糸礤ō躅轹弪筢飙糸礤躅轼屦镢璀溟骀弪孱沐┅ㄤ彐躅躅轼麸躅轹弪筢飙糸礤躅轼糸礤ǐ躅轼糸礤躅轼屦镢璀溟骀弪孱沐┅ㄤ彐躅珏舡躅轼糸礤ī躅轹弪筢飙麸躅轼糸礤ㄧ弭躅轹弪筢飙糸礤┅ㄤ彐躅糸礤麸篝颞筱绛糸礤ㄩ铛礅弪筱绛糸礤眭祠轲戾鲠祯瀛忾钿箦泔钿黹铛翦栾躜溽翦盹铘遽溽镦麇咫潴舡酊ㄤ邈镤瀛躅轹弪筢飙糸礤躅轼麸躅轹弪筢飙糸礤ㄦ祜矧ǒ筱绛糸礤卑鞍┅┅ㄦ矧磲铋铂О浜铂О浜铂О浏铂О浏ㄇ驮冷栾躜黹铛翦箦泔钿盹铘溽翦遽ō酊┅筱绛糸礤┅ㄤ彐躅溴泔溴溽翦膂膂ㄣ镱è矧箦狎汨溽翦ㄦ轵篝膂┅箦狎汨Ⅳ轫澧ㄦ轵篝膂┅箦狎汨㈧狍粼轫辶袈躞郁狒澧ㄦ轵篝膂┅扉篝ㄦ轵篝膂糸礤麸篝蝈篝膂┅┅扉篝ㄦ轵篝膂ㄤ邈镤瀛溽翦蝈篝膂┅┅┅ㄤ彐躅溴泔溴溽翦蟥飑ㄣ镱è铛祆飑飑è铒扉篝飑飑è羼踽ㄦ轵篝飑猴怅扉篝猴怅磲疸狎＇溴泔溴溽翦膂蝈篝飑┅扉篝ㄤ邈镤瀛溽翦ㄦ轵篝飑ㄤ邈镤瀛溽翦蝈篝飑┅┅ㄤ彐躅蝻豸弪犰歙趄篝屦ㄨ趑瓠珏蝻豸弪螈＇灬礅溽牦┄犷扉篝牦戾铉翳牦癌ㄦ躅汜祆ㄣ镱翎轭Ⅱ彐ㄦ轵篝牦┅┅＇灬礅溽牦ㄦ躅汜祆ㄦ轵瀛弼孱候秕翦颟牦秣詈鲠ㄦ轵篝牦Ⅱ彐┅┅ㄤ彐躅蝻豸弪铄鳕脲钺礤㈩犴澧ㄤ弩泸轲糸镱溴筱蜷痿轱睥┅趄篝屦ㄨ趑瓠痫篝蝻豸弪螈牦秣詈铄鳝牦á钺礤钺礤á溴筱蜷痿轱睥溴筱蜷痿轱瞟┅＇灬礅溽牦ㄡ钿扉篝牦ㄦ躅汜祆ㄣ镱翎轭Ⅱ彐牦┅＇灬礅溽牦ㄦ躅汜祆ㄦ轵瀛弼孱候秕翦颟牦秣詈鲠牦Ⅱ彐┅┅ㄤ彐躅蝻豸弪瘐舁脲ㄩㄧ弭弼孱候秕翦颟钺礤㈩犴澧ㄤ弩泸轲糸镱溴筱蜷痿轱睥┅趄篝屦ㄨ趑瓠瘐扉篝蝻豸弪螈殇牦秣詈铄鳝牦á钺礤钺礤á溴筱蜷痿轱睥溴筱蜷痿轱瞟┅＇灬礅溽牦ㄡ钿扉篝牦ㄦ躅汜祆ㄣ镱翎轭Ⅱ彐牦┅＇灬礅溽牦ㄦ躅汜祆ㄦ轵瀛弼孱候秕翦颟牦秣詈鲠牦Ⅱ彐┅┅ㄤ彐躅蝻豸弪箦舁脲ㄩㄧ弭弼孱候秕翦颟钺礤㈩犴澧ㄤ弩泸轲糸镱溴筱蜷痿轱睥┅趄篝屦ㄨ趑瓠痫篝扉篝蝻豸弪螈殇牦秣詈铄鳝牦á钺礤钺礤á溴筱蜷痿轱睥溴筱蜷痿轱瞟┅＇灬礅溽牦ㄡ钿扉篝牦ㄦ躅汜祆ㄣ镱翎轭Ⅱ彐牦┅＇灬礅溽牦ㄦ躅汜祆ㄦ轵瀛弼孱候秕翦颟牦秣詈鲠牦Ⅱ彐┅┅ㄤ彐躅蝻豸弪é脲ㄩㄧ弭弼孱候秕翦颟┅趄篝屦ㄨ趑瓠珏蝻豸弪螈殇＇灬礅溽牦ㄡ钿扉篝牦ㄦ躅汜祆ㄣ镱翎轭Ⅱ彐牦┅＇灬礅溽牦ㄦ躅汜祆ㄦ轵瀛弼孱候秕翦颟殇┅┅ㄤ彐躅蝻豸弪溴歙脲ㄩㄧ弭弼孱候秕翦颟┅趄篝屦ㄨ趑瓠溴蝻豸弪螈殇＇灬礅溽牦ㄥ聃犰牦┅＇灬礅溽牦ㄣ戾狎弼孱候秕翦颟┅换箅殪ㄤ彐躅箅殪飙犰歙脲蝻豸弪殇ㄧ弭弼孱候秕翦颟疱颦疳珏蛋疳珏铛礅弪暴趄篝屦ㄨ趑瓠珏蝻豸弪螈蝻豸弪殇ㄦ矧磲铋Ⅲ腴祆罂疱蜻疳珏浸力疳珏哳蹴浸立疱颦疳珏疳珏铛礅弪┅＇灬礅溽牦ㄡ钿扉篝牦ㄦ躅汜祆ㄣ镱翎轭Ⅱ彐ㄦ轵篝牦┅┅＇灬礅溽牦ㄦ躅汜祆ㄦ轵瀛弼孱后腴祆牦秣詈鲠ㄦ轵篝牦Ⅱ彐┅┅ㄤ彐躅箅殪歙脲蝻豸弪殇ㄧ弭弼孱候秕翦颟ㄩㄧ弭弼孱后腴祆┅趄篝屦ㄨ趑瓠珏蝻豸弪螈蝻豸弪殇Ⅲ腴祆螈殇＇灬礅溽牦ㄡ钿扉篝牦ㄦ躅汜祆ㄣ镱翎轭Ⅱ彐牦┅＇灬礅溽牦ㄦ躅汜祆ㄦ轵瀛弼孱后腴祆牦秣詈鲠牦Ⅱ彐┅┅ㄤ彐躅箅殪飙溴歙脲蝻豸弪殇ㄧ弭弼孱候秕翦颟ㄩㄧ弭弼孱后腴祆┅趄篝屦ㄨ趑瓠溴蝻豸弪螈蝻豸弪殇Ⅲ腴祆螈殇＇灬礅溽牦ㄥ聃犰牦┅＇灬礅溽牦ㄣ戾狎弼孱后腴祆┅┅ㄤ彐躅箅殪飙铄鳕脲蝻豸弪殇ㄧ弭弼孱候秕翦颟ㄤ弩泸轲糸镱溴筱蜷痿轱睥眭祠轹犰蹂呼蝓濠ㄤ镯衢牦秣詈铄鳝牦á鲠祯弩Ж㈠睥㈠螈┅á豉疱㈠铛礤蜥糸镱┅┅趄篝屦ㄨ趑瓠痫篝扉篝蝻豸弪螈蝻豸弪殇Ⅲ腴祆螈牦秣詈铄鳝牦á溴筱蜷痿轱睥溴筱蜷痿轱瞟á滹磲轭滹磲轭á眭祠轹犰蹂眭祠轹犰蹂┅＇灬礅溽牦┄犷扉篝牦ㄦ躅汜祆ㄣ镱翎轭Ⅱ彐牦┅＇灬礅溽牦┄骢钽犰ㄦ轵瀛弼孱后腴祆牦秣詈鲠牦Ⅱ彐┅┅ㄤ彐躅箅殪飙瘐舁脲蝻豸弪殇ㄧ弭弼孱候秕翦颟ㄩㄧ弭弼孱后腴祆┅ㄡ滗蝈篌⑨滗蝈篌ㄣ狃徕殪轸殄牦秣詈铄鳝牦á灬铉踽珏㈠睥┅┅趄篝屦ㄨ趑瓠瘐扉篝蝻豸弪螈蝻豸弪殇Ⅲ腴祆螈殇牦秣詈铄鳝牦á徜潋弩螈徜潋弩螬á汜疳忾扉糸弩汜疳忾扉糸弩┅＇灬礅溽牦ㄡ钿扉篝牦ㄦ躅汜祆ㄣ镱翎轭Ⅱ彐牦┅＇灬礅溽牦ㄦ躅汜祆ㄦ轵瀛弼孱后腴祆牦秣詈鲠牦Ⅱ彐┅┅ㄤ彐躅箅殪飙箦舁脲蝻豸弪殇ㄧ弭弼孱候秕翦颟ㄩㄧ弭弼孱后腴祆┅ㄡ滗蝈篌⑨滗蝈篌篝狒Ⅱ遽澌换镦骒轭怩簌ㄣ狃徕殪轸殄牦秣詈铄鳝牦á灬铉踽珏㈠睥┅┅趄篝屦ㄨ趑瓠痫篝扉篝蝻豸弪螈蝻豸弪殇Ⅲ腴祆螈殇牦秣詈铄鳝牦á徜潋弩螈徜潋弩螬á篝狒澧篝狒濠á汜疳忾扉糸弩汜疳忾扉糸弩┅＇灬礅溽牦ㄡ钿扉篝牦ㄦ躅汜祆ㄣ镱翎轭Ⅱ彐牦┅＇灬礅溽牦ㄦ躅汜祆ㄦ轵瀛弼孱后腴祆牦秣詈鲠牦Ⅱ彐┅┅换徵孱ㄤ彐躅徵孱舡犰歙脲蝻豸弪殇ㄧ弭弼孱候秕翦颟疱颦疳珏蛋疳珏铛礅弪暴趄篝屦ㄨ趑瓠珏蝻豸弪螈蝻豸弪殇ㄦ矧磲铋⑨珏铘罂疱蜻疳珏浸力疳珏哳蹴浸立疱颦疳珏疳珏铛礅弪┅＇灬礅溽牦ㄡ钿扉篝牦ㄦ躅汜祆ㄣ镱翎轭Ⅱ彐ㄦ轵篝牦┅┅＇灬礅溽牦ㄦ躅汜祆ㄦ轵瀛弼孱横珏铘牦秣詈鲠ㄦ轵篝牦Ⅱ彐┅┅ㄤ彐躅徵孱舁脲蝻豸弪殇ㄧ弭弼孱候秕翦颟ㄩㄧ弭弼孱横珏铘┅趄篝屦ㄨ趑瓠珏蝻豸弪螈蝻豸弪殇⑨珏铘螈殇＇灬礅溽牦ㄡ钿扉篝牦ㄦ躅汜祆ㄣ镱翎轭Ⅱ彐牦┅＇灬礅溽牦ㄦ躅汜祆ㄦ轵瀛弼孱横珏铘牦秣詈鲠牦Ⅱ彐┅┅ㄤ彐躅徵孱舡溴歙脲蝻豸弪殇ㄧ弭弼孱候秕翦颟ㄩㄧ弭弼孱横珏铘┅趄篝屦ㄨ趑瓠溴蝻豸弪螈蝻豸弪殇⑨珏铘螈殇＇灬礅溽牦ㄥ聃犰牦┅＇灬礅溽牦ㄣ戾狎弼孱横珏铘┅┅ㄤ彐躅徵孱舡铄鳕脲蝻豸弪殇ㄧ弭弼孱候秕翦颟ㄡ滗蝈篌⑨滗蝈篌翎Ⅲ镯瀛轭骘ㄣ狃徕殪轸殄牦秣詈铄鳝牦á灬铉踽珏㈠睥á翎纰翎绌┅趄篝屦ㄨ趑瓠痫篝扉篝蝻豸弪螈蝻豸弪殇⑨珏铘螈牦秣詈铄鳝牦á徜潋弩螈徜潋弩螬á汜疳忾扉糸弩汜疳忾扉糸弩┅＇灬礅溽牦┄犷扉篝牦ㄦ躅汜祆ㄣ镱翎轭Ⅱ彐牦┅＇灬礅溽牦┄骢钽犰ㄦ轵瀛弼孱横珏铘牦秣詈鲠牦Ⅱ彐┅┅ㄤ彐躅徵孱舡瘐舁脲蝻豸弪殇ㄧ弭弼孱候秕翦颟ㄩㄧ弭弼孱横珏铘┅ㄡ滗蝈篌⑨滗蝈篌ㄣ狃徕殪轸殄牦秣詈铄鳝牦á灬铉踽珏㈠睥┅┅趄篝屦ㄨ趑瓠瘐扉篝蝻豸弪螈蝻豸弪殇⑨珏铘螈殇牦秣詈铄鳝牦á徜潋弩螈徜潋弩螬á汜疳忾扉糸弩汜疳忾扉糸弩┅＇灬礅溽牦ㄡ钿扉篝牦ㄦ躅汜祆ㄣ镱翎轭Ⅱ彐牦┅＇灬礅溽牦ㄦ躅汜祆ㄦ轵瀛弼孱横珏铘牦秣詈鲠牦Ⅱ彐┅┅ㄤ彐躅徵孱舡箦舁脲蝻豸弪殇ㄧ弭弼孱候秕翦颟ㄩㄧ弭弼孱横珏铘┅ㄡ滗蝈篌⑨滗蝈篌篝狒Ⅱ遽澌换镦骒轭怩簌ㄣ狃徕殪轸殄牦秣詈铄鳝牦á灬铉踽珏㈠睥┅┅趄篝屦ㄨ趑瓠痫篝扉篝蝻豸弪螈蝻豸弪殇⑨珏铘螈殇牦秣詈铄鳝牦á徜潋弩螈徜潋弩螬á篝狒澧篝狒濠á汜疳忾扉糸弩汜疳忾扉糸弩┅＇灬礅溽牦ㄡ钿扉篝牦ㄦ躅汜祆ㄣ镱翎轭Ⅱ彐牦┅＇灬礅溽牦ㄦ躅汜祆ㄦ轵瀛弼孱横珏铘牦秣詈鲠牦Ⅱ彐┅┅ㄤ彐躅轭箦螋轭麸翎忪鲠祯弩戾è沩ㄦ矧磲铋㈨篑溽翎忉箦姐镯眢唑秕翦蜻泔蝈蝻雉疳篌黠蜾姐镯眢蝻豸弪ч铙弪轭麸至陶庞窿蕃)'"
                     table values)))
    (format t "%A" cmd)
    (UIOP:run-program cmd :input nil :output '(:string :stripped t) :IGNORE-ERROR-STATUS t)
    ))
(defun add-quote(text)(format nil "\"A\"" text))
(defun bind-agent-to-queue(&key (agent-id (get-event :agent))
                     (queue-id (get-event :queue)))
  (insert-into "agent_queue" (list (add-quote agent-id) (add-quote queue-id))))
;;; plan
(defun plan-all(&key (router-id (get-event :router)) )
  (tr-step (http-get "/routers" router-id "plans")
           #'(lambda(js) (and (listp js) (funcall (contains "ref") (first js))))
           #'(lambda(js) (funcall (fire-event :plan) (jsown:val (first js) "ref")))))

(defun plan-new(&key (router-id (get-event :router))
                  (queue-id (get-event :queue))
                  (default-queue-id (get-event :queue))
                  (predicate "1 ==1")
                  (priority 0)
                  (next-route nil)
                  (timeout 3600)
                  (rules (list (jsown:new-js ("tag" "test-rule")
                                             ("predicate" predicate)
                                             ("routes" (append
                                                        (list (jsown:new-js
                                                                ("queueRef" queue-id)
                                                                ("priority" priority)
                                                                ("timeout" timeout)))
                                                        next-route)))))
                  (default-route (jsown:new-js
                                   ("queueRef" default-queue-id)
                                   ("priority" 0)
                                   ("timeout" 360000)))
                  (description "description"))
  (tr-step (http-post (list "/routers" router-id "plans")
                      (jsown:new-js
                        ("rules" rules)
                        ("description" description)
                        ("defaultRoute" default-route)))
           #'(lambda(js) (and (listp js) (funcall (contains "ref") js)))
           #'(lambda(js) (funcall (fire-event :plan) (jsown:val js "ref")))))

(defun plan-set(&key (router-id (get-event :router))
                  (id (get-event :plan))
                  (tag (get-id "test-rule"))
                  (predicate "1 == 1")
                  (description "plan description")
                  (queue (get-event :queue))
                  (rules (list (jsown:new-js ("tag" tag) ("predicate" predicate) ("queueRef" queue)))) )
  (tr-step (http-post (list "/routers" router-id "plans" id)
                      (jsown:new-js
                                   ("rules" rules)
                                   ("description" description)                                    ))
           #'(lambda(js) (and (listp js) (funcall (contains "ref") js)))
           #'(lambda(js) (funcall (fire-event :queue) (jsown:val js "ref")))))
(defun plan(&key (router-id (get-event :router))
              (id (get-event :plan)))
  (tr-step (http-get "/routers" router-id "plans" id )
           #'(lambda(js) (and (listp js) (funcall (contains "ref") js)))
           #'(lambda(js) (funcall (fire-event :plan) (jsown:val js "ref")))))

(defun plan-put(&key (router-id (get-event :router))
                  (id (get-event :plan))
                  (tag (get-id "test-rule"))
                  (predicate "1 == 1")
                  (description "plan description")
                  (queue (get-event :queue))
                  (rules (list (jsown:new-js ("tag" tag) ("predicate" predicate) ("queueRef" queue)))) )
  (tr-step (http-put (list "/routers" router-id "plans" id)
                     (jsown:new-js ("rules" rules)
                                   ("description" description)                                    ))
           #'(lambda(js) (and (listp js) (funcall (contains "ref") js)))
           #'(lambda(js) (funcall (fire-event :plan) (jsown:val js "ref")))))

(defun plan-del(&key (router-id (get-event :router))
                  (id (get-event :plan)))
  (tr-step (http-del "/routers" router-id "plans" id)
           #'(lambda(js) (equal js ""))
           #'(lambda(js) (clear-event :plan))))

;;; queue
(defun queue-all(&key (router-id (get-event :router)) (per-page 50) (page-number 1) )
  (tr-step (http-get "/routers" router-id (format nil "queues?per_page=A&page_num=A" per-page page-number))
           #'(lambda(js) (and (listp js) (funcall (contains "ref") (first js))))
           #'(lambda(js) (funcall (fire-event :queue) (jsown:val (first js) "ref")))))

(defun queue(&key (router-id (get-event :router))
               (id (get-event :queue)))
  (tr-step (http-get "/routers" router-id "queues" id)
           #'(lambda(js) (and (listp js) (funcall (contains "ref") js)))
           #'(lambda(js) (funcall (fire-event :queue) (jsown:val js "ref")))))

(defun queue-size(&key (router-id (get-event :router))
               (id (get-event :queue)))
  (tr-step (http-get "/routers" router-id "queues" id "size")
           #'(lambda(js)(and (listp js) (funcall (contains "size") js)))
           #'(lambda(js) (funcall (fire-event :queue) id))))

(defun queue-tasks(&key (router-id (get-event :router))
                    (id (get-event :queue)))
  (tr-step (http-get "/routers" router-id "queues" id "tasks")
           #'(lambda(js)(and (listp js) (funcall (contains "size") js)))
           #'(lambda(js) (funcall (fire-event :queue) id))))

(defun queue-put(&key (router-id (get-event :router))
                   (id (get-event :queue))
                   (description "description")
                   (predicate "1==1") )
  (tr-step (http-put (list "/routers" router-id "queues" id) (jsown:new-js
                                                               ("description" description)
                                                               ("predicate" predicate)))
           #'(lambda(js) (and (listp js) (funcall (contains "ref") js)))
           #'(lambda(js) (funcall (fire-event :queue) (jsown:val js "ref")))))

(defun queue-set(&key (router-id (get-event :router))
                   (id (get-event :queue))
                   (description "description")
                   (predicate :null) )
  (tr-step (http-post (list "/routers" router-id "queues" id)
                      (jsown:new-js
                       ("description" description)
                       ("predicate" predicate)))
           #'(lambda(js) (and (listp js) (funcall (contains "ref") js)))
           #'(lambda(js) (funcall (fire-event :queue) (jsown:val js "ref")))))

(defun queue-del(&key (router-id (get-event :router))
                   (id (get-event :queue)))
  (tr-step (http-del "/routers" router-id "queues" id)
           #'(lambda(js) (equal js ""))
           #'(lambda(js) (clear-event :queue))))

(defun queue-new(&key (router-id (get-event :router))
                   (description "description")
                   (predicate "1==1"))
  (tr-step (http-post (list "/routers" router-id "queues")
                      (jsown:new-js ("description" description)
                                    ("predicate" predicate)))
           #'(lambda(js) (and (listp js) (funcall (contains "ref") js)))
           #'(lambda(js) (funcall (fire-event :queue) (jsown:val js "ref")))))
;;; task
(defun task-all(&key (router-id (get-event :router))
                  (per-page 50) (page-number 1))
  (tr-step (http-get "/routers" router-id (format nil "tasks?per_page=A&per_num" per-page page-number))
           #'(lambda(js) (and (listp js) (funcall (contains "ref") (first js))))
           #'(lambda(js) (funcall (fire-event :task) (jsown:val (first js) "ref")))))

(defun task(&key (router-id (get-event :router))
              (id (get-event :task)))
  (tr-step (http-get "/routers" router-id "tasks" id)
           #'(lambda(js) (and (listp js) (funcall (contains "ref") js)))
           #'(lambda(js) (funcall (fire-event :task) (jsown:val js "ref")))))

(defun task-context(&key (router-id (get-event :router))
              (id (get-event :task)))
  (tr-step (http-get "/routers" router-id "tasks" id "user_context")
           #'(lambda(js) (and (listp js) ))
           #'(lambda(js) )))

(defun task-put(&key (router-id (get-event :router))
                  (id (get-event :task))
                  (requirements (jsown:new-js ("key" t)))
                  (callback-url (format nil "http://192.168.1.171:8787/?task"))
                  (queue-id (get-event :queue))
                  (plan-id :null))
  (tr-step (http-put (list "/routers" router-id "tasks" id)
                     (jsown:new-js
                       ("callbackUrl" callback-url)

                       ("requirements" requirements)
                       ("queueRef" queue-id)
                       ("planRef" plan-id)))
           #'(lambda(js) (and (listp js) (funcall (contains "ref") js)))
           #'(lambda(js) (funcall (fire-event :task) (jsown:val js "ref")))))

(defun task-set(&key (router-id (get-event :router))
                  (id (get-event :task))
                  (state "completed")
                  )
  (tr-step (http-post (list "/routers" router-id "tasks" id)
                     (jsown:new-js ("state" state)
                                   ))
           #'(lambda(js) (and (listp js) (funcall (contains "ref") js)))
           #'(lambda(js) (funcall (fire-event :task) (jsown:val js "ref")))))
(defun task-del(&key (router-id (get-event :router))
                   (id (get-event :task)))
  (tr-step (http-del  "/routers" router-id "tasks" id)
           #'(lambda(js)(equal js ""))
           #'(lambda(js) (clear-event :task))))

(defun task-new(&key (router-id (get-event :router))

                  (requirements (jsown:new-js ("key" t)))
                  (callback-url (format nil "http://localhost:4343/task?router=A&sleep=A" router-id (random 2)))
                  (context (jsown:new-js ("key" "value")))
                  (queue-id (get-event :queue))
                  (plan-id :null) )
  (tr-step (http-post (list "/routers" router-id "tasks")
                      (jsown:new-js
                        ("callbackUrl" callback-url)
                        ("userContext" context)
                        ("requirements" requirements)
                        ("queueRef" queue-id)
                        ("planRef" plan-id)
                        ))
           #'(lambda(js) (and (listp js) (funcall (contains "ref") js)))
           #'(lambda(js) (funcall (fire-event :task) (jsown:val js "ref")))))

(defun ptask-new(&key (router-id (get-event :router))
                   (requirements (jsown:new-js))
                   (callback-url (format nil "http://192.168.1.171:8787/?task="))
                   (context (jsown:new-js ("key" "value")))
                   (plan-id (get-event :plan)))
  (task-new :router-id router-id
            :requirements requirements
            :callback-url callback-url
            :queue-id :null
            :context context
            :plan-id plan-id))
