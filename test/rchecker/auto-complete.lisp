(in-package :rchecker)
(defparameter *times* ())
(defun autocomplete-task(router-id task-id)
  (destructuring-bind (response check description)
      (funcall (tand
                (etask :router-id router-id :id task-id :state "assigned")
                (etask-set :router-id router-id :id task-id :state "completed")))
    (list (list response check description)
            (funcall (tand (etask-set-context :router-id router-id :task-id task-id :key "result" :value (if check t :false))
                           (let ((descr (format nil "~S" description)))
                             (etask-set-context  :router-id router-id :task-id task-id
                                                 :key "log" :value (ppcre:regex-replace-all "'" ""
                                                                                            (subseq descr (max 0 (- (length descr) 255))))))
                           ) )) ) )

(defvar *lock* (bt:make-lock))
(defvar *to-complete* ())

(hunchentoot:define-easy-handler (app :uri "/task") (data)
  (setf (hunchentoot:content-type*) "text/plain")
  (let ((body (when (hunchentoot:raw-post-data)(babel:octets-to-string (hunchentoot:raw-post-data)))))
    (hunchentoot:log-message* 'requ "~(~A~):~A Body:~A" "app" (hunchentoot:query-string*) body)
    (let* ((start-time (get-internal-real-time))
           (task-info (jsown:parse body))
           (task (jsown:val task-info "task"))
           (task-id (jsown:val task "ref"))
           (router-id (jsown:val task "routerRef"))
           (delay (hunchentoot:parameter "sleep")))
      (bt:make-thread #'(lambda()
                          (sleep (parse-integer delay))
                          (let ((res (autocomplete-task router-id task-id)))
                            (if (some #'null (mapcar #'second res))
                                "ERROR"
                                (push (get-internal-real-time) *times*)))
                          )
                      :name "auto-completer")
      (hunchentoot:log-message* 'ready "completed in ~A" (- (get-internal-real-time) start-time))
      "OK")))

(hunchentoot:define-easy-handler (handle-slow :uri "/handle-slow") (data)
  (setf (hunchentoot:content-type*) "text/plain")
  (let ((body (when (hunchentoot:raw-post-data)(babel:octets-to-string (hunchentoot:raw-post-data)))))
    (hunchentoot:log-message* 'requ "~(~A~):~A Body:~A" "app" (hunchentoot:query-string*) body)
    (let* ((start-time (get-internal-real-time))
           (task-info (jsown:parse body))
           (task (jsown:val task-info "task"))
           (task-id (jsown:val task "ref"))
           (router-id (jsown:val task "routerRef"))
           (delay (hunchentoot:parameter "sleep"))
           (delay-after (hunchentoot:parameter "sleep-after")))
      (sleep (parse-integer delay))
      (let ((res (autocomplete-task router-id task-id)))
        (if (some #'null (mapcar #'second res))
            "ERROR"
            (push (get-internal-real-time) *times*)))
      (sleep (parse-integer delay-after))
      (hunchentoot:log-message* 'ready "completed in ~A" (- (get-internal-real-time) start-time))
      "OK")))

(hunchentoot:define-easy-handler (recreate-task :uri "/complete-and-create-task") (data)
  (setf (hunchentoot:content-type*) "text/plain")
  (let ((body (when (hunchentoot:raw-post-data)(babel:octets-to-string (hunchentoot:raw-post-data)))))
    ;;(hunchentoot:log-message* 'requ "~(~A~):~A Body:~A" "app" (hunchentoot:query-string*) body)
    (let* ((start-time (get-internal-real-time))
           (task-info (jsown:parse body))
           (task (jsown:val task-info "task"))
           (task-id (jsown:val task "ref"))
           (router-id (jsown:val task "routerRef"))
           (delay (hunchentoot:parameter "sleep")))
      (bt:make-thread #'(lambda()
                          (sleep (parse-integer delay))
                          (let ((res (funcall (tand (etask-set :router-id router-id :id task-id :state "completed")
                                                    (etask-new :router-id router-id :callback-url (jsown:val task "callbackUrl"))
                                                    ))))
                            (push (if (second res) (get-internal-real-time) res)
                                  *times*)) )
                      :name "auto-completer")
      (hunchentoot:log-message* 'ready "completed in ~A" (- (get-internal-real-time) start-time))
      "OK")))
(defparameter *enabled* t)

(hunchentoot:define-easy-handler (enable :uri "/enable") ()
  (setf (hunchentoot:content-type*) "text/plain")
  (setf *active* t)
  "enabled")

(hunchentoot:define-easy-handler (disable :uri "/disable") ()
  (setf (hunchentoot:content-type*) "text/plain")
  (setf *active* nil)
  "disabled")

(hunchentoot:define-easy-handler (create-tasks :uri "/create-tasks") (router queue max-tasks delay)
  (setf (hunchentoot:content-type*) "text/plain")
  (when *active*
    (bt:make-thread
     #'(lambda()
         (let ((res (funcall (equeue-size :router-id router :id queue))))
           (with-output-to-string(s)
             (if (second res)
                 (let ((observed-tasks (jsown:val (first res) "size"))
                       (expected-tasks (parse-integer max-tasks)))
                   (if (> expected-tasks observed-tasks )
                       (mapcar
                        #'print-log
                        (remove-if
                         #'second
                         (lparallel:pmapcar
                          #'(lambda(i)(funcall (etask-new :router-id router :queue-id queue
                                                          :callback-url (format nil "http://~A/schedule-task?delay=~A&max-tasks=~A" "localhost:4343" delay max-tasks))))
                          (loop :repeat (- expected-tasks observed-tasks) :collect 1))))
                       "queue is full"))
                 (print-log res))))
         :name "auto-completer")))
  "OK")

(hunchentoot:define-easy-handler (schedule-task :uri "/schedule-task") (delay max-tasks)
  (setf (hunchentoot:content-type*) "text/plain")
  (let ((body (when (hunchentoot:raw-post-data)(babel:octets-to-string (hunchentoot:raw-post-data)))))
    (hunchentoot:log-message* 'schedule "~(~A~):~A Body:~A" "app" (hunchentoot:query-string*) body)
    (let* ((start-time (get-internal-real-time))
           (task-info (jsown:parse body))
           (task (jsown:val task-info "task"))
           (queue-id (jsown:val task "queueRef"))
           (task-id (jsown:val task "ref"))
           (router-id (jsown:val task "routerRef")))
      (bt:make-thread #'(lambda()
                          (sleep (parse-integer delay))
                          (drakma:http-request (format nil "http://localhost:4343/complete-task?max-tasks=~A&delay=~A&router=~A&task=~A&queue=~A" max-tasks delay router-id task-id queue-id))
                          :name "auto-completer"))
      "OK")))

(hunchentoot:define-easy-handler (complete-task :uri "/complete-task") (max-tasks delay router task queue)
  (setf (hunchentoot:content-type*) "text/plain")
  (bt:make-thread #'(lambda()
                      (funcall (etask-set :router-id router :id task :state "completed"))
                      (drakma:http-request "http://localhost:4343/task-completed")
                      (drakma:http-request (format nil "http://localhost:4343/create-tasks?max-tasks=~A&delay=~A&router=~A&queue=~A" max-tasks delay router queue))
                      :name "auto-completer")))

(hunchentoot:define-easy-handler (complete-task :uri "/task-completed") ()
  (setf (hunchentoot:content-type*) "text/plain")
  (push (get-internal-real-time) *times*))

(hunchentoot:define-easy-handler (retry :uri "/503") (data)
  (setf (hunchentoot:content-type*) "text/plain")
  (setf (hunchentoot:return-code*) (list 503))
  (hunchentoot:log-message* 'requ "~(~A~):~A Body:~A" "app" (hunchentoot:query-string*) (when (hunchentoot:raw-post-data)(babel:octets-to-string (hunchentoot:raw-post-data))))
  "reserved for testing")

(hunchentoot:define-easy-handler (not-found :uri "/404") (data)
  (setf (hunchentoot:content-type*) "text/plain")
  (setf (hunchentoot:return-code*) (list 503))
  "reserved for testing")

(defvar *server* (make-instance 'hunchentoot:easy-acceptor :port 4343
                                ;;:taskmaster (make-instance 'hunchentoot:single-threaded-taskmaster)
                                ))
(defun start-server()  (hunchentoot:start *server*))
(defun stop-server()  (hunchentoot:stop *server*))

;;(setf (hunchentoot:TASKMASTER-MAX-THREAD-COUNT (hunchentoot::acceptor-taskmaster *server*)) 200)
;;(setf (hunchentoot::acceptor-access-log-destination *server*) nil)
;;(drakma:http-request (format nil "http://localhost:4343/create-tasks?router=~A&queue=~A&max-tasks=10" (get-event :router) (get-event :queue)) )
;;(drakma:http-request (format nil "http://localhost:4343/schedule-task?router=~A&queue=~A&task=~A" (get-event :router) (get-event :queue) (get-event :task)) )
